/**
 * @file varicode.h
 * @author Joshua Jerred
 * @details Simple set of lookup tables for varicode. This is useful for 
 * encoding and decoding QPSK/PSK31/BPSK31 and any other varicode applications.
 * 
 * IMPORTANT -- No zero padding is added to the end or beginning of the 
 * varicode string.
 * 
 * @date 2022-11-18
 * @copyright Copyright (c) 2022
 */

#ifndef VARICODE_H_
#define VARICODE_H_

#include <string>
#include <unordered_map>

/**
 * @brief A simple lookup table for converting char -> varicode string
 * 
 */
const char* const ascii_to_varicode[128] = {
    // ASCII Control Characters (0 - 31)
    "1010101011", // 0	    [NUL]	Null character
    "1011011011", // 1	    [SOH]	Start of Header
    "1011101101", // 2	    [STX]	Start of Text
    "1101110111", // 3	    [ETX]	End of Text
    "1011101011", // 4	    [EOT]	End of Transmission
    "1101011111", // 5	    [ENQ]	Enquiry
    "1011101111", // 6	    [ACK]	Acknowledgment
    "1011111101", // 7	    [BEL]	Bell
    "1011111111", // 8	    [BS]	Backspace
    "11101111",	  // 9	    [HT]	Horizontal Tab
    "11101",	  // 10	    [LF]	Line feed
    "1101101111", // 11	    [VT]	Vertical Tab
    "1011011101", // 12	    [FF]	Form feed
    "11111",	  // 13	    [CR]	Carriage return
    "1101110101", // 14	    [SO]	Shift Out
    "1110101011", // 15	    [SI]	Shift In
    "1011110111", // 16	    [DLE]	Data Link Escape
    "1011110101", // 17	    [DC1]	Device Control 1 (XON)
    "1110101101", // 18	    [DC2]	Device Control 2
    "1110101111", // 19	    [DC3]	Device Control 3 (XOFF)
    "1101011011", // 20	    [DC4]	Device Control 4
    "1101101011", // 21	    [NAK]	Negative Acknowledgement
    "1101101101", // 22	    [SYN]	Synchronous Idle
    "1101010111", // 23	    [ETB]	End of Trans. Block
    "1101111011", // 24	    [CAN]	Cancel
    "1101111101", // 25	    [EM]	End of Medium
    "1110110111", // 26	    [SUB]	Substitute
    "1101010101", // 27	    [ESC]	Escape
    "1101011101", // 28	    [FS]	File Separator
    "1110111011", // 29	    [GS]	Group Separator
    "1011111011", // 30	    [RS]	Record Separator
    "1101111111", // 31	    [US]	Unit Separator
    
    // ASCII Printable Characters (32 - 126)
    "1",          //    32	[Space]
    "111111111",  //    33	!
    "101011111",  //    34	"
    "111110101",  //    35	#
    "111011011",  //    36	$
    "1011010101", //    37	%
    "1010111011", //    38	&
    "101111111",  //    39	'
    "11111011",   //    40	(
    "11110111",   //    41	)
    "101101111",  //    42	*
    "111011111",  //    43	+
    "1110101",    //    44	, 
    "110101",     //	45	-
    "1010111",    //	46	.
    "110101111",  //	47	/
    "10110111",   //	48	0
    "10111101",   //	49	1
    "11101101",   //	50	2
    "11111111",   //	51	3
    "101110111",  //	52	4
    "101011011",  //	53	5
    "101101011",  //	54	6
    "110101101",  //	55	7
    "110101011",  //	56	8
    "110110111",  //	57	9
    "11110101",   //	58	:
    "110111101",  //	59	;
    "111101101",  //	60	<
    "1010101",    //	61	=
    "111010111",  //	62	>
    "1010101111", //	63	?
    "1010111101", //	64	@
    "1111101",    //	65	A
    "11101011",   //	66	B
    "10101101",   //	67	C
    "10110101",   //	68	D
    "1110111",    //	69	E
    "11011011",   //	70	F
    "11111101",   //	71	G
    "101010101",  //	72	H
    "1111111",    //	73	I
    "111111101",  //	74	J
    "101111101",  //	75	K
    "11010111",   //	76	L
    "10111011",   //	77	M
    "11011101",   //	78	N
    "10101011",   //	79	O
    "11010101",   //	80	P
    "111011101",  //	81	Q
    "10101111",   //	82	R
    "1101111",    //	83	S
    "1101101",    //	84	T
    "101010111",  //	85	U
    "110110101",  //	86	V
    "101011101",  //	87	W
    "101110101",  //	88	X
    "101111011",  //	89	Y
    "1010101101", //	90	Z
    "111110111",  //	91	[
    "111101111",  //	92	[backslash]
    "111111011",  //	93	]
    "1010111111", //	94	^
    "101101101",  //	95	_
    "1011011111", //	96	'
    "1011",       //	97	a
    "1011111",    //	98	b
    "101111",     //	99	c
    "101101",     //	100	d
    "11",         //	101	e
    "111101",     //	102	f
    "1011011",    //	103	g
    "101011",     //	104	h
    "1101",       //	105	i
    "111101011",  //	106	j
    "10111111",   //	107	k
    "11011",      //	108	l
    "111011",     //	109	m
    "1111",       //	110	n
    "111",        //	111	o
    "111111",     //	112	p
    "110111111",  //	113	q
    "10101",      //	114	r
    "10111",      //	115	s
    "101",        //	116	t
    "110111",     //	117	u
    "1111011",    //	118	v
    "1101011",    //	119	w
    "11011111",   //	120	x
    "1011101",    //	121	y
    "111010101",  //	122	z
    "1010110111", //	123	{
    "110111011",  //	124	|
    "1010110101", //	125	}
    "1011010111", //	126	~
    "1110110101"  //	127	[DEL]
};

/**
 * @brief Simple unordered_map to convert a string representation of varicode
 * to a char.
 */
static std::unordered_map<std::string, int> varicode_to_ascii = {
    // ASCII Control Characters (0 - 31)
    {"1010101011"   ,   0   }, // 0	    [NUL]	Null character
    {"1011011011"   ,   1   }, // 1	    [SOH]	Start of Header
    {"1011101101"   ,   2   }, // 2	    [STX]	Start of Text
    {"1101110111"   ,   3   }, // 3	    [ETX]	End of Text
    {"1011101011"   ,   4   }, // 4	    [EOT]	End of Transmission
    {"1101011111"   ,   5   }, // 5	    [ENQ]	Enquiry
    {"1011101111"   ,   6   }, // 6	    [ACK]	Acknowledgment
    {"1011111101"   ,   7   }, // 7	    [BEL]	Bell
    {"1011111111"   ,   8   }, // 8	    [BS]	Backspace
    {"11101111"     ,   9   }, // 9	    [HT]	Horizontal Tab
    {"11101"        ,   10  }, // 10	    [LF]	Line feed
    {"1101101111"   ,   11  }, // 11	    [VT]	Vertical Tab
    {"1011011101"   ,   12  }, // 12	    [FF]	Form feed
    {"11111"        ,   13  }, // 13	    [CR]	Carriage return
    {"1101110101"   ,   14  }, // 14	    [SO]	Shift Out
    {"1110101011"   ,   15  }, // 15	    [SI]	Shift In
    {"1011110111"   ,   16  }, // 16	    [DLE]	Data Link Escape
    {"1011110101"   ,   17  }, // 17	    [DC1]	Device Control 1 (XON)
    {"1110101101"   ,   18  }, // 18	    [DC2]	Device Control 2
    {"1110101111"   ,   19  }, // 19	    [DC3]	Device Control 3 (XOFF)
    {"1101011011"   ,   20  }, // 20	    [DC4]	Device Control 4
    {"1101101011"   ,   21  }, // 21	    [NAK]	Negative Acknowledgement
    {"1101101101"   ,   22  }, // 22	    [SYN]	Synchronous Idle
    {"1101010111"   ,   23  }, // 23	    [ETB]	End of Trans. Block
    {"1101111011"   ,   24  }, // 24	    [CAN]	Cancel
    {"1101111101"   ,   25  }, // 25	    [EM]	End of Medium
    {"1110110111"   ,   26  }, // 26	    [SUB]	Substitute
    {"1101010101"   ,   27  }, // 27	    [ESC]	Escape
    {"1101011101"   ,   28  }, // 28	    [FS]	File Separator
    {"1110111011"   ,   29  }, // 29	    [GS]	Group Separator
    {"1011111011"   ,   30  }, // 30	    [RS]	Record Separator
    {"1101111111"   ,   31  }, // 31	    [US]	Unit Separator

    // ASCII Printable Characters (32 - 126)
    {"1"            ,	32	}, //	Space
    {"111111111"    ,   33  }, //	!
    {"101011111"	,	34	}, //	"
    {"111110101"	,	35	}, //	#
    {"111011011"	,	36	}, //	$
    {"1011010101"	,	37	}, //	%
    {"1010111011"	,	38	}, //	&
    {"101111111"	,	39	}, //	'
    {"11111011"	    ,	40	}, //	(
    {"11110111"	    ,	41	}, //	)
    {"101101111"	,	42	}, //	*
    {"111011111"	,	43	}, //	+
    {"1110101"	    ,	44	}, //	,
    {"110101"	    ,	45	}, //	-
    {"1010111"	    ,	46	}, //	.
    {"110101111"	,	47	}, //	/
    {"10110111"	    ,	48	}, //	0
    {"10111101"	    ,	49	}, //	1
    {"11101101"	    ,	50	}, //	2
    {"11111111"	    ,	51	}, //	3
    {"101110111"	,	52	}, //	4
    {"101011011"	,	53	}, //	5
    {"101101011"	,	54	}, //	6
    {"110101101"	,	55	}, //	7
    {"110101011"	,	56	}, //	8
    {"110110111"	,	57	}, //	9
    {"11110101"	    ,	58	}, //	:
    {"110111101"	,	59	}, //	;
    {"111101101"	,	60	}, //	<
    {"1010101"	    ,	61	}, //	=
    {"111010111"	,	62	}, //	>
    {"1010101111"	,	63	}, //	?
    {"1010111101"	,	64	}, //	@
    {"1111101"	    ,	65	}, //	A
    {"11101011"	    ,	66	}, //	B
    {"10101101"	    ,	67	}, //	C
    {"10110101"	    ,	68	}, //	D
    {"1110111"	    ,	69	}, //	E
    {"11011011"	    ,	70	}, //	F
    {"11111101"	    ,	71	}, //	G
    {"101010101"	,	72	}, //	H
    {"1111111"	    ,	73	}, //	I
    {"111111101"	,	74	}, //	J
    {"101111101"	,	75	}, //	K
    {"11010111"	    ,	76	}, //	L
    {"10111011"	    ,	77	}, //	M
    {"11011101"	    ,	78	}, //	N
    {"10101011"	    ,	79	}, //	O
    {"11010101"	    ,	80	}, //	P
    {"111011101"	,	81	}, //	Q
    {"10101111"	    ,	82	}, //	R
    {"1101111"	    ,	83	}, //	S
    {"1101101"	    ,	84	}, //	T
    {"101010111"	,	85	}, //	U
    {"110110101"	,	86	}, //	V
    {"101011101"	,	87	}, //	W
    {"101110101"	,	88	}, //	X
    {"101111011"	,	89	}, //	Y
    {"1010101101"   ,   90  }, //	Z
    {"111110111"    ,   91  }, //	[
    {"111101111"    ,   92  }, //	[backslash]
    {"111111011"    ,   93  }, //	]
    {"1010111111"   ,   94  }, //	^
    {"101101101"    ,   95  }, //	_
    {"1011011111"   ,   96  }, //	'
    {"1011"         ,   97  }, //	a
    {"1011111"      ,   98  }, //	b
    {"101111"       ,   99  }, //	c
    {"101101"	    ,	100	}, //	d
    {"11"	        ,	101	}, //	e
    {"111101"	    ,	102	}, //	f
    {"1011011"	    ,	103	}, //	g
    {"101011"	    ,	104	}, //	h
    {"1101"	        ,	105	}, //	i
    {"111101011"	,	106	}, //	j
    {"10111111"	    ,	107	}, //	k
    {"11011"	    ,	108	}, //	l
    {"111011"	    ,	109	}, //	m
    {"1111"	        ,	110	}, //	n
    {"111"	        ,	111	}, //	o
    {"111111"	    ,	112	}, //	p
    {"110111111"	,	113	}, //	q
    {"10101"	    ,	114	}, //	r
    {"10111"	    ,	115	}, //	s
    {"101"	        ,	116	}, //	t
    {"110111"	    ,	117	}, //	u
    {"1111011"	    ,	118	}, //	v
    {"1101011"	    ,	119	}, //	w
    {"11011111"	    ,	120	}, //	x
    {"1011101"	    ,	121	}, //	y
    {"111010101"	,	122	}, //	z
    {"1010110111"	,	123	}, //	{
    {"110111011"	,	124	}, //	|
    {"1010110101"	,	125	}, //	}
    {"1011010111"	,	126	}, //	~
    {"1110110101"	,	127	} //	[DEL]
};

#endif